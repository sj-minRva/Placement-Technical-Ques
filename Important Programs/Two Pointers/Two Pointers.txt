 Two-Pointer Technique
Definition

Two-pointer technique uses two indices (pointers) that traverse the array (or string) in a coordinated 
way to solve problems in linear or linear-ish time. Pointers can move:
from opposite ends toward each other (left/right), or in the same direction (fast/slow), or one pointer scans while the other lags (window boundaries, partitioning).
It’s especially powerful on sorted arrays or when you need to find pairs/triplets, remove elements in-place, or detect cycles.

When to use:
Searching for a pair with a given sum in a sorted array.
Removing duplicates/in-place rearrangements.
Reversing, partitioning, merging tasks.
Linked-list cycle detection (fast/slow pointers).

Complexity:
Time: usually O(n) (each pointer moves at most n steps).
Space: O(1) extra space for in-place variants.


Example 1 — Two Sum II (Sorted array) (LeetCode 167)

Problem: given sorted array nums and target, find indices of two numbers that add to target.

Idea (two pointers from ends)

l = 0, r = n-1

If nums[l] + nums[r] == target → found.

If sum < target → l++ (increase sum).

If sum > target → r-- (decrease sum).

Walkthrough

nums = [2, 3, 4, 8, 11], target = 12
l=0 (2), r=4 (11): sum=13>12 → r→3 (8)
l=0 (2), r=3 (8): sum=10<12 → l→1 (3)
l=1 (3), r=3 (8): sum=11<12 → l→2 (4)
l=2 (4), r=3 (8): sum=12 → found indices (2,3)

Code — Python
def two_sum_sorted(nums, target):
    l, r = 0, len(nums)-1
    while l < r:
        s = nums[l] + nums[r]
        if s == target:
            return (l+1, r+1)  # often problem expects 1-based
        if s < target:
            l += 1
        else:
            r -= 1
    return None

Code — Java
public int[] twoSumSorted(int[] nums, int target) {
    int l = 0, r = nums.length - 1;
    while (l < r) {
        int sum = nums[l] + nums[r];
        if (sum == target) return new int[]{l+1, r+1};
        if (sum < target) l++;
        else r--;
    }
    return new int[]{-1, -1};
}

Example 2 — Fast/Slow (Floyd cycle detection / finding duplicates)

Use slow moves 1 step, fast moves 2 steps. If they meet, cycle exists.

For arrays interpreted as pointers (index as next), this finds duplicate via cycle.

Common pitfalls & tips

Two-pointer requires ordered relations (like sorted arrays) for direction decisions; otherwise, it may fail.

Be careful with off-by-one when moving pointers and when returning indices (0-based vs 1-based).

Fast/slow pointers: always check fast and fast.next existence to avoid null errors (linked lists); similarly check index bounds for arrays.